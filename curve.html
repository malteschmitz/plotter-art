<!doctype html>
<html>
<head>
	<title>Catmullâ€“Rom spline</title>
	<meta charset='utf-8'>
</head>
<body>
<svg id="svg" xmlns="http://www.w3.org/2000/svg" width="400" viewBox="0 0 100 100"></svg>

<script>
  // https://stackoverflow.com/questions/30748316/catmull-rom-interpolation-on-svg-paths

  // https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html

  function newSvg(tag) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }

  // let points = [[5,5],[5,5],[15,15],[25,5],[30,8],[35,4],[35,4]];
  let points = [[84, 91], [84, 91], [68, 19], [21, 17], [32, 91], [32, 91]];
  
  let alpha = 0.5;

  function distance(a, b) {
    return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));
  }

  function getT(t, a, b) {
    return t + Math.pow(distance(a,b), alpha);
  }

  function catmullRom(points) {
    let result = [];
    for (let i = 0; i < points.length - 3; i++) {
      let t0 = 0;
      let t1 = getT(t0, points[i], points[i+1]);
      let t2 = getT(t1, points[i+1], points[i+2]);
      let t3 = getT(t2, points[i+2], points[i+3]);

      console.log(t0, t1, t2, t3);

      let c1 = (t2-t1)/(t2-t0);
      let c2 = (t1-t0)/(t2-t0);
      let d1 = (t3-t2)/(t3-t1);
      let d2 = (t2-t1)/(t3-t1);

      console.log(c1, c2, d1, d2);

      let m1, m2;
      if (points[i+0][0] == points[i+1][0] && points[i+0][1] == points[i+1][1]) {
        m1 = [
          (t2-t1)*(c2*(points[i+2][0]-points[i+1][0])/(t2-t1)),
          (t2-t1)*(c2*(points[i+2][1]-points[i+1][1])/(t2-t1))
          ];
      } else {
        m1 = [
          (t2-t1)*(c1*(points[i+1][0]-points[i+0][0])/(t1-t0) + c2*(points[i+2][0]-points[i+1][0])/(t2-t1)),
          (t2-t1)*(c1*(points[i+1][1]-points[i+0][1])/(t1-t0) + c2*(points[i+2][1]-points[i+1][1])/(t2-t1))
          ];
      }
      
      if (points[i+2][0] == points[i+3][0] && points[i+2][1] == points[i+3][1]) {
        m2 = [
          (t2-t1)*(d1*(points[i+2][0]-points[i+1][0])/(t2-t1)),
          (t2-t1)*(d1*(points[i+2][1]-points[i+1][1])/(t2-t1))
        ];
      } else {
        m2 = [
          (t2-t1)*(d1*(points[i+2][0]-points[i+1][0])/(t2-t1) + d2*(points[i+3][0]-points[i+2][0])/(t3-t2)),
          (t2-t1)*(d1*(points[i+2][1]-points[i+1][1])/(t2-t1) + d2*(points[i+3][1]-points[i+2][1])/(t3-t2))
        ];
      }

      console.log(m1, m2);

      result.push([
        [points[i+1][0] + m1[0]/3, points[i+1][1] + m1[1]/3],
        [points[i+2][0] - m2[0]/3, points[i+2][1] - m2[1]/3],
        points[i+2]
      ]);
    }
    return result;
  }

  let cmPoints = catmullRom(points);

  function point(p, color) {
    color ||= "red";
    let [x,y] = p;
    let circle = newSvg("circle");
    circle.setAttribute("fill", color);
    circle.setAttribute("r", "1");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    svg.appendChild(circle);
  }

  function line(a, b) {
    let line = newSvg("line");
    line.setAttribute("stroke", "orange");
    line.setAttribute("stroke-width", "0.5");
    line.setAttribute("x1", a[0]);
    line.setAttribute("y1", a[1]);
    line.setAttribute("x2", b[0]);
    line.setAttribute("y2", b[1]);
    svg.appendChild(line);
  }

  function bezierre(start, points) {
    let d = `M ${start[0]} ${start[1]} `;
    for (let i = 0; i < points.length; i++) {
      let p = points[i];
      d += `C ${p[0][0]} ${p[0][1]}, ${p[1][0]} ${p[1][1]}, ${p[2][0]} ${p[2][1]} `;
    }
    let path = newSvg("path");
    path.setAttribute("stroke", "blue");
    path.setAttribute("stroke-width", "0.5");
    path.setAttribute("fill", "transparent");
    path.setAttribute("d", d);
    svg.appendChild(path); 
  }

  bezierre(points[1], cmPoints);

  points.forEach(p => point(p));
  for (let i = 0; i < cmPoints.length; i++) {
    line(points[i+1], cmPoints[i][0]);
    point(cmPoints[i][0], "orange");
    line(points[i+2], cmPoints[i][1]);
    point(cmPoints[i][1], "orange");
  }
</script>

</body>
</html>
